(*
    Сам по собі такий код не працює, тому що у такому випадку let-прив'язка визначає значення, а не функцію.
    Значення же не може існувати без конкретного типу-параметру.
    Тут же це значення ніяк не використовується, тому і компілятор не може вивести конкретний тип-параметр.
*)
// let print = printfn "%A"

(*
    Якщо ж ми додамо виклик значення print, то компілятор зможе вивести тип-параметр і код компілюватиметься.
    Але ми тоді зможемо викликати це значення тільки з тим самим типом-параметром.
    Це як зі створенням екземпляру узагальненого списку:
    let list = System.Collections.Generic.List()
    list.Add 5
*)
// print 10
