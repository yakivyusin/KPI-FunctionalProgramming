// ('a -> 'b) -> 'a -> 'b
let apply f x = f x

// 'a -> ('a -> 'b) -> 'b
let applyBack x f = f x

(*
    Компілятор спочатку компілює лямбду.
    Якщо у її коді достатньо інформації, щоб вивести тип для типу-параметра,
    то відповідний тип буде для всієї узагальненої функції.
*)
apply (fun x -> x * x) 10 // 'a = int, 'b = int

(*
    Тут у нас інформації недостатньо, потрібна анотація типу
    'a = string, 'b = int
*)
apply (fun (x: string) -> x.Length) "Hello, World"

(*
    Замість анотації типу ми можемо використати |> щоб "переставити" порядок параметрів.
    Тоді компілятор під час компіляції лямбди вже буде знати, що 'a = string, і анотація не потрібна.
*)
"Hello, World" |> apply (fun x -> x.Length)

(*
    З applyBack такої проблеми немає, тому що значення йде спочатку.
    Але такий вигляд функцій погано об'єднується у конвеєри, тому перший варіант разом з |> набагато популярніший.
*)
applyBack 10 (fun x -> x * x)
applyBack "Hello, World" (fun x -> x.Length)

// Так з applyBack не вийде
"Hello, World" |> apply (fun x -> x.Length) |> apply (fun x -> x + 1) |> apply (fun x -> x.ToString())

// Де повернуте значення якось використовується, компілятор буде виводити тип на основі цього.
// ('a -> int) -> 'a -> int
let toIntAndSquare f x = (f x) * (f x)

toIntAndSquare (fun x -> System.Int32.Parse(x)) "10"
