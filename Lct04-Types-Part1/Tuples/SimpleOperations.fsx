let square x = x * x
let add x y = x + y

// int * int
let t1 = 1, 2

// Теж int * int
let t2 = (1, 2)

// int * bool * string * float
let t3 = 42, true, "Hello", 1.42

// (string * string) * int
let t4 = ("John", "Doe"), 42

// (int -> int) * (int -> int -> int)
let t5 = square, add

// Кортеж у F# не може мати значення null.
// fail: let t6: (int * int) = null

(*
    Як і в C#, оператор рівності для кортежів автоматично перевизначений.
    Кортежі рівні один одному, якщо вони мають однаковий тип та їх елементи попарно рівні.
    Спроба перевірити рівність кортежів різних типів викличуть помилку компіляції про неспівпадіння типів.
*)
t1 = t2
t1 = (1, 3)
// fail: t1 = t3
// fail: t1 = t5
// fail: (1, 2, 3) = ((1, 2), 3)

(*
    Крім рівності, ми також можемо автоматично порівнювати кортежі, якщо типи елементів це підтримують.
    Спочатку порівнюються перші елементи, якщо вони рівні то другі і так далі.
*)
(1, 2) < (2, 3)
(1, 2) < (1, 3)
(1, 2) < (1, 2)

(*
    У F# у кортежу недоступні властивості виду Item1, Item2 як у C#.
    Єдиний спосіб працювати зі значеннями з кортежу - деконструювати його.
    Компілятор нам автоматично виведе тип окремих значень, взятих із кортежу.
*)
let a, b = t1
a + b

let c, d = t5
5 |> c |> d 100

// Так само ми можемо відразу деконструювати вкладений кортеж
let name, age = t4
let (firstName, lastName), shirtSize = t4

(*
    Якщо якісь значення із кортежу не потрібні, пропускаємо їх за допомогою _.
    Компілятор видасть помилку, якщо ми вкажемо неправильну кількість елементів під час деконструювання.
*)
let e, f, _, _ = t3
// fail: let g, h = t3

(*
    Крім деконструювання, також є дві вбудовані функції для взяття першого та другого елемента кортежу.
    Але вони працюють тільки з кортежами із двох елементів.
*)
let g = fst t1
let h = snd t5
// fail: let j = fst t3
